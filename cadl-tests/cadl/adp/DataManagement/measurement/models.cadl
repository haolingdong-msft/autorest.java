using Cadl.Http;
using Cadl.Rest;
using Azure.Core;

namespace Adp;

enum Clients {
  MeasurementClient,
  MeasurementStateMachineClient,
  MeasurementMetadataClient,
  MeasurementProcessingResultsClient,
  MeasurementMetadataFileInfoClient,
  MeasurementMetadataSchemaFileInfoClient,
}

@parentResource(Measurement)
@resource("stateMachines")
@doc("State machine")
model StateMachine {
  @doc("The state machine identifier.")
  @key
  id: string;

  @doc("Type of the state machine")
  type: string;

  @doc("Type of the state machine")
  availableActionNames: string[];
}

@doc("State machine action name.")
model StateMachineAction {
  @doc("The state machine action name.")
  actionName: string;
}

@doc("A measurement resource")
@resource("measurements")
model Measurement {
  @doc("The measurement identifier.")
  @key
  measurementId: string;
  /*   @doc("The measurement state")
  @visibility("update")
  state?: MeasurementState;

  @doc("The measurement current status")
  @visibility("update")
  executionStatus?: MeasurementStateExecutionStatus; */


  @doc("The storage account location which contains the measurement")
  location: string;

  @doc("The UTC time the measurement was ingested at")
  ingestTimestampUtc?: zonedDateTime;
  ...CommonResourceEndpoint;

  @doc(" The ID of the external package (for example, the disk which contained data) as specified by the customer upon data ingestion")
  externalPackageId?: string;

  @doc("ID of the upload process which caused the creation of this measurement")
  uploadId?: string;

  @doc("ID of the discovery process which caused the creation of this measurement")
  discoveryId?: string;

  @doc("The UTC time the measurement was recorded at")
  recordTimestampUtc?: zonedDateTime;
  ...Azure.Core.Foundations.Extensions.CustomEtagProperty;
}

@doc("Custom query data set: Measurement and metadata.")
model MeasurementWithMetadata {
  ...Measurement;
  ...MeasurementMetadataBase;
}

@doc("Measurement processing result.")
@resource("processingResults")
@parentResource(Measurement)
model MeasurementProcessingResults {
  @doc(
    """
  The {name} identifier.
  Not in use as this is a singleton resource.
  TODO: check with CADL team how to define a singleton child resource without key.
  """,
    MeasurementProcessingResults
  )
  @key
  id: string;
  ...MeasurementProcessingResultsBase;
}

@doc("Measurement metadata without resource identifier.")
model MeasurementMetadataBase {
  @doc("The measurement metadata dictionary")
  metadata: Record<string>;
}

@doc("Measurement metadata.")
@resource("metadata")
@parentResource(Measurement)
model MeasurementMetadata {
  @doc(
    """
  The {name} identifier.
  Not in use as this is a singleton resource.
  TODO: check with CADL team how to define a singleton child resource without key.
  """,
    MeasurementMetadata
  )
  @key
  id: string;
  ...MeasurementMetadataBase;
}

@doc("Measurement metadata file information model.")
model MeasurementMetadataFileInfoBase {
  @doc("The measurement's metadata file name")
  metadataFileName: string;

  @doc("""
  SAS signed URI to measurement metadata file.
  If file already exists on storage then ETag of this file will be returned in the response header.
  This URI expires in 24 hours.
  """)
  metadataFileUri: uri;
  ...EtagResponseEnvelope;
}

@doc("Measurement metadata file information resource.")
@resource("metadataFileInfo")
@parentResource(Measurement)
model MeasurementMetadataFileInfo {
  @doc(
    """
  The {name} identifier.
  Not in use as this is a singleton resource.
  TODO: check with CADL team how to define a singleton child resource without key.
  """,
    MeasurementMetadataFileInfo
  )
  @key
  id: string;
  ...MeasurementMetadataFileInfoBase;
}

@doc("Measurement metadata schema file information model.")
model MeasurementMetadataSchemaFileInfoBase {
  @doc("Measurement schema file name.")
  schemaFileName?: string;

  @doc("""
  SAS signed URI for downloading the measurement metadata schema file from Azure Storage.
  This URI expires in 24 hours.
  """)
  schemaFileUri: uri;
}

@doc("Measurement metadata schema file information resource.")
@resource("metadataSchemaFileInfo")
@parentResource(Measurement)
model MeasurementMetadataSchemaFileInfo {
  @doc(
    """
  The {name} identifier.
  Not in use as this is a singleton resource.
  TODO: check with CADL team how to define a singleton child resource without key.
  """,
    MeasurementMetadataSchemaFileInfo
  )
  @key
  id: string;
  ...MeasurementMetadataSchemaFileInfoBase;
}

/* @summary("TODO: REMOVE - not in use")
@doc("Change measurement state request parameter")
model ChangeMeasurementStateRequestParameters {
  @doc("Desired measurement state.")
  state: MeasurementState;
} */

@doc("Request parameters for the complete upload metadata file API")
model CompleteUploadMetadataFileRequest {
  @doc("The ETag of the uploaded metadata file")
  pendingFileETag: string;
}

@doc("A wrapper for the List of measurements IDs")
model MeasurementListRequestParameters {
  @doc("The measurement IDs list")
  measurementIds: string[];
}

/* @summary("TODO: REMOVE - not in use")
@doc("Represents possible measurement states")
@knownValues(MeasurementStateKV)
model MeasurementState is string;
enum MeasurementStateKV {
  New: "New",
  Operational: "Operational",
} */

@doc("A wrapper for the List of measurements IDs")
model MeasurementIdList {
  @doc("The measurement IDs list")
  measurementIds: string[];
}

/* @summary("TODO: REMOVE - not in use")
@doc("Measurement metadata - new entries descriptor")
model MeasurementMetadataNewEntries {
  @doc("The entries to be updated")
  entries: MeasurementMetadataNewEntry[];
} */

/* @summary("TODO: REMOVE - not in use")
@doc("Measurement metadata new entry information")
model MeasurementMetadataNewEntry {
  ...CommonKeyValuePair;
} */

/* @summary("TODO: REMOVE - not in use")
@doc("Measurement metadata update entries")
model MeasurementMetadataUpdateEntries {
  @doc("The entries to be updated")
  entries: MeasurementMetadataUpdateEntry[];
}

@doc("Measurement metadata entry update information")
model MeasurementMetadataUpdateEntry {
  @doc("The key")
  key: string;

  @doc("The old value")
  oldValue: string;

  @doc("The new value")
  newValue: string;
}

@summary("TODO: REMOVE - not in use")
@doc("An error that occurred while trying to fetch a measurement's schema file")
@knownValues(MeasurementSchemaErrorCodeKV)
model MeasurementSchemaErrorCode is string;
enum MeasurementSchemaErrorCodeKV {
  SchemaUriExtractionFailed: "SchemaUriExtractionFailed",
  CustomerDefaultSchemaUriCouldNotBeResolved: "CustomerDefaultSchemaUriCouldNotBeResolved",
  SchemaFetchingFailed: "SchemaFetchingFailed",
  SavingSchemaToStorageFailed: "SavingSchemaToStorageFailed",
  SchemaUriNotAllowedByTenant: "SchemaUriNotAllowedByTenant",
  Unknown: "Unknown",
}

@summary("TODO: REMOVE - not in use")
@doc("The measurement's execution status")
@knownValues(MeasurementStateExecutionStatusKV)
model MeasurementStateExecutionStatus is string;
enum MeasurementStateExecutionStatusKV {
  Running: "Running",
  Succeeded: "Succeeded",
  Failed: "Failed",
  Deleting: "Deleting",
}
*/

@summary("TODO: REMOVE - not in use")
@doc("The measurement's validation result")
@withOptionalProperties
model MeasurementProcessingResultsBase {
  @doc("The measurement's validity")
  validationPassed: boolean;

  @doc("The measurement's rule validation results")
  results: MeasurementRuleValidationResult[];
}

@doc("The result of evaluation of measurement validation rule")
@withOptionalProperties
model MeasurementRuleValidationResult {
  @doc("Measurement validation rule category")
  ruleCategory: string;

  @doc("Measurement validation rule name")
  ruleName: string;

  @doc("Measurement validation rule metadata")
  details: Record<string>;

  @doc("Measurement validation rule evaluation result")
  validationPassed: boolean;

  @doc("Measurement validation error message")
  validationError?: string;
}
